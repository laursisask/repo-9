{"version":3,"file":"validator-ajv6.cjs.production.min.js","sources":["../src/createAjvInstance.ts","../src/validator.ts","../src/customizeValidator.ts","../src/index.ts"],"sourcesContent":["import Ajv from \"ajv\";\nimport isObject from \"lodash/isObject\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\n\nexport const AJV_CONFIG = {\n  errorDataPath: \"property\",\n  allErrors: true,\n  multipleOfPrecision: 8,\n  schemaId: \"auto\",\n  unknownFormats: \"ignore\",\n} as const;\nexport const COLOR_FORMAT_REGEX =\n  /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/;\nexport const DATA_URL_FORMAT_REGEX =\n  /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;\n\n/** Creates an Ajv version 6 implementation object with standard support for the 'color` and `data-url` custom formats.\n * If `additionalMetaSchemas` are provided then the Ajv instance is modified to add each of the meta schemas in the\n * list. If `customFormats` are provided then those additional formats are added to the list of supported formats. If\n * `ajvOptionsOverrides` are provided then they are spread on top of the default `AJV_CONFIG` options when constructing\n * the `Ajv` instance.\n *\n * @param [additionalMetaSchemas] - The list of additional meta schemas that the validator can access\n * @param [customFormats] - The set of additional custom formats that the validator will support\n * @param [ajvOptionsOverrides={}] - The set of validator config override options\n * @deprecated in favor of the `@rjsf/validator-ajv8\n */\nexport default function createAjvInstance(\n  additionalMetaSchemas?: CustomValidatorOptionsType[\"additionalMetaSchemas\"],\n  customFormats?: CustomValidatorOptionsType[\"customFormats\"],\n  ajvOptionsOverrides: CustomValidatorOptionsType[\"ajvOptionsOverrides\"] = {}\n) {\n  const ajv = new Ajv({ ...AJV_CONFIG, ...ajvOptionsOverrides });\n\n  // add custom formats\n  ajv.addFormat(\"data-url\", DATA_URL_FORMAT_REGEX);\n  ajv.addFormat(\"color\", COLOR_FORMAT_REGEX);\n\n  // add more schemas to validate against\n  if (Array.isArray(additionalMetaSchemas)) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n  }\n\n  // add more custom formats to validate against\n  if (isObject(customFormats)) {\n    Object.keys(customFormats).forEach((formatName) => {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n  }\n\n  return ajv;\n}\n","import { Ajv, ErrorObject } from \"ajv\";\nimport toPath from \"lodash/toPath\";\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorSchemaBuilder,\n  ErrorTransformer,\n  FieldValidation,\n  FormContextType,\n  FormValidation,\n  GenericObjectType,\n  RJSFSchema,\n  RJSFValidationError,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n  getDefaultFormState,\n  isObject,\n  mergeValidationData,\n  ERRORS_KEY,\n  REF_KEY,\n} from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport createAjvInstance from \"./createAjvInstance\";\n\nconst ROOT_SCHEMA_PREFIX = \"__rjsf_rootSchema\";\n\n/** `ValidatorType` implementation that uses the AJV 6 validation mechanism.\n *\n * @deprecated in favor of the `@rjsf/validator-ajv8\n */\nexport default class AJV6Validator<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> implements ValidatorType<T, S, F>\n{\n  /** The AJV instance to use for all validations\n   *\n   * @private\n   */\n  private ajv: Ajv;\n\n  /** Constructs an `AJV6Validator` instance using the `options`\n   *\n   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance\n   */\n  constructor(options: CustomValidatorOptionsType) {\n    const { additionalMetaSchemas, customFormats, ajvOptionsOverrides } =\n      options;\n    this.ajv = createAjvInstance(\n      additionalMetaSchemas,\n      customFormats,\n      ajvOptionsOverrides\n    );\n  }\n\n  /** Transforms a ajv validation errors list:\n   * [\n   *   {property: '.level1.level2[2].level3', message: 'err a'},\n   *   {property: '.level1.level2[2].level3', message: 'err b'},\n   *   {property: '.level1.level2[4].level3', message: 'err b'},\n   * ]\n   * Into an error tree:\n   * {\n   *   level1: {\n   *     level2: {\n   *       2: {level3: {errors: ['err a', 'err b']}},\n   *       4: {level3: {errors: ['err b']}},\n   *     }\n   *   }\n   * };\n   *\n   * @param errors - The list of RJSFValidationError objects\n   * @private\n   */\n  private toErrorSchema(errors: RJSFValidationError[]): ErrorSchema<T> {\n    const builder = new ErrorSchemaBuilder<T>();\n    if (errors.length) {\n      errors.forEach((error) => {\n        const { property, message } = error;\n        const path = toPath(property);\n\n        // If the property is at the root (.level1) then toPath creates\n        // an empty array element at the first index. Remove it.\n        if (path.length > 0 && path[0] === \"\") {\n          path.splice(0, 1);\n        }\n        if (message) {\n          builder.addErrors(message, path);\n        }\n      });\n    }\n    return builder.ErrorSchema;\n  }\n\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath: string[] = []) {\n    if (!errorSchema) {\n      return [];\n    }\n    let errorList: RJSFValidationError[] = [];\n    if (ERRORS_KEY in errorSchema) {\n      errorList = errorList.concat(\n        errorSchema.__errors!.map((message: string) => {\n          const property = `.${fieldPath.join(\".\")}`;\n          return {\n            property,\n            message,\n            stack: `${property} ${message}`,\n          };\n        })\n      );\n    }\n    return Object.keys(errorSchema).reduce((acc, key) => {\n      if (key !== ERRORS_KEY) {\n        acc = acc.concat(\n          this.toErrorList((errorSchema as GenericObjectType)[key], [\n            ...fieldPath,\n            key,\n          ])\n        );\n      }\n      return acc;\n    }, errorList);\n  }\n\n  /** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\n   *\n   * @param formData - The form data around which the error handler is created\n   * @private\n   */\n  private createErrorHandler(formData: T): FormValidation<T> {\n    const handler: FieldValidation = {\n      // We store the list of errors for this node in a property named __errors\n      // to avoid name collision with a possible sub schema field named\n      // 'errors' (see `utils.toErrorSchema`).\n      __errors: [],\n      addError(message: string) {\n        this.__errors!.push(message);\n      },\n    };\n    if (isObject(formData)) {\n      const formObject: GenericObjectType = formData as GenericObjectType;\n      return Object.keys(formObject).reduce((acc, key) => {\n        return { ...acc, [key]: this.createErrorHandler(formObject[key]) };\n      }, handler as FormValidation<T>);\n    }\n    if (Array.isArray(formData)) {\n      return formData.reduce((acc, value, key) => {\n        return { ...acc, [key]: this.createErrorHandler(value) };\n      }, handler);\n    }\n    return handler as FormValidation<T>;\n  }\n\n  /** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError` functions from it\n   *\n   * @param errorHandler - The `FormValidation` error handling structure\n   * @private\n   */\n  private unwrapErrorHandler(errorHandler: FormValidation<T>): ErrorSchema<T> {\n    return Object.keys(errorHandler).reduce((acc, key) => {\n      if (key === \"addError\") {\n        return acc;\n      } else if (key === ERRORS_KEY) {\n        return { ...acc, [key]: (errorHandler as GenericObjectType)[key] };\n      }\n      return {\n        ...acc,\n        [key]: this.unwrapErrorHandler(\n          (errorHandler as GenericObjectType)[key]\n        ),\n      };\n    }, {} as ErrorSchema<T>);\n  }\n\n  /** Transforming the error output from ajv to format used by @rjsf/utils.\n   * At some point, components should be updated to support ajv.\n   *\n   * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\n   * @private\n   */\n  private transformRJSFValidationErrors(\n    errors: ErrorObject[] = []\n  ): RJSFValidationError[] {\n    return errors.map((e: ErrorObject) => {\n      const { dataPath, keyword, message, params, schemaPath } = e;\n      const property = `${dataPath}`;\n\n      // put data in expected format\n      return {\n        name: keyword,\n        property,\n        message,\n        params, // specific to ajv\n        stack: `${property} ${message}`.trim(),\n        schemaPath,\n      };\n    });\n  }\n\n  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use\n   * by the playground. Returns the `errors` from the validation\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData - The form data to validate\n   */\n  rawValidation<Result = any>(\n    schema: RJSFSchema,\n    formData?: T\n  ): { errors?: Result[]; validationError?: Error } {\n    let validationError: Error | undefined = undefined;\n    try {\n      this.ajv.validate(schema, formData);\n    } catch (err) {\n      validationError = err as Error;\n    }\n\n    const errors = this.ajv.errors || undefined;\n\n    // Clear errors to prevent persistent errors, see #1104\n    this.ajv.errors = null;\n\n    return { errors: errors as unknown as Result[], validationError };\n  }\n\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\n   */\n  validateFormData(\n    formData: T | undefined,\n    schema: S,\n    customValidate?: CustomValidator<T, S, F>,\n    transformErrors?: ErrorTransformer<T, S, F>,\n    uiSchema?: UiSchema<T, S, F>\n  ): ValidationData<T> {\n    const rootSchema = schema;\n\n    const rawErrors = this.rawValidation<ErrorObject>(schema, formData);\n    const { validationError } = rawErrors;\n    let errors = this.transformRJSFValidationErrors(rawErrors.errors);\n\n    const noProperMetaSchema =\n      validationError &&\n      validationError.message &&\n      validationError.message.includes(\"no schema with key or ref \");\n\n    if (noProperMetaSchema) {\n      errors = [...errors, { stack: validationError!.message }];\n    }\n    if (typeof transformErrors === \"function\") {\n      errors = transformErrors(errors, uiSchema);\n    }\n\n    let errorSchema = this.toErrorSchema(errors);\n\n    if (noProperMetaSchema) {\n      errorSchema = {\n        ...errorSchema,\n        ...{\n          $schema: {\n            __errors: [validationError!.message],\n          },\n        },\n      };\n    }\n\n    if (typeof customValidate !== \"function\") {\n      return { errors, errorSchema };\n    }\n\n    // Include form data with undefined values, which is required for custom validation.\n    const newFormData = getDefaultFormState<T, S, F>(\n      this,\n      schema,\n      formData,\n      rootSchema,\n      true\n    ) as T;\n\n    const errorHandler = customValidate(\n      newFormData,\n      this.createErrorHandler(newFormData),\n      uiSchema\n    );\n    const userErrorSchema = this.unwrapErrorHandler(errorHandler);\n    return mergeValidationData<T, S, F>(\n      this,\n      { errors, errorSchema },\n      userErrorSchema\n    );\n  }\n\n  /** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixObject(node: object) {\n    for (const key in node) {\n      const realObj: { [k: string]: any } = node;\n      const value = realObj[key];\n      if (\n        key === REF_KEY &&\n        typeof value === \"string\" &&\n        value.startsWith(\"#\")\n      ) {\n        realObj[key] = ROOT_SCHEMA_PREFIX + value;\n      } else {\n        realObj[key] = this.withIdRefPrefix(value);\n      }\n    }\n    return node;\n  }\n\n  /** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param node - The list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixArray(node: object[]): RJSFSchema {\n    for (let i = 0; i < node.length; i++) {\n      node[i] = this.withIdRefPrefix(node[i]);\n    }\n    return node as RJSFSchema;\n  }\n\n  /** Validates data against a schema, returning true if the data is valid, or\n   * false otherwise. If the schema is invalid, then this function will return\n   * false.\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData- - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   */\n  isValid(schema: RJSFSchema, formData: T | undefined, rootSchema: RJSFSchema) {\n    try {\n      // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n      // then rewrite the schema ref's to point to the rootSchema\n      // this accounts for the case where schema have references to models\n      // that lives in the rootSchema but not in the schema in question.\n      const result = this.ajv\n        .addSchema(rootSchema, ROOT_SCHEMA_PREFIX)\n        .validate(this.withIdRefPrefix(schema), formData);\n      return result as boolean;\n    } catch (e) {\n      return false;\n    } finally {\n      // make sure we remove the rootSchema from the global ajv instance\n      this.ajv.removeSchema(ROOT_SCHEMA_PREFIX);\n    }\n  }\n\n  /** Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`\n   * This is used in isValid to make references to the rootSchema\n   *\n   * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @protected\n   */\n  protected withIdRefPrefix(schemaNode: RJSFSchema): RJSFSchema {\n    if (schemaNode.constructor === Object) {\n      return this.withIdRefPrefixObject({ ...schemaNode });\n    }\n    if (Array.isArray(schemaNode)) {\n      return this.withIdRefPrefixArray([...schemaNode]);\n    }\n    return schemaNode;\n  }\n}\n","import {\n  FormContextType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  ValidatorType,\n} from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport AJV6Validator from \"./validator\";\n\n/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if\n * provided.\n *\n * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance\n * @deprecated in favor of the `@rjsf/validator-ajv8\n */\nexport default function customizeValidator<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(options: CustomValidatorOptionsType = {}): ValidatorType<T, S, F> {\n  return new AJV6Validator<T, S, F>(options);\n}\n","import customizeValidator from \"./customizeValidator\";\n\nexport { customizeValidator };\nexport * from \"./types\";\n\n/** @deprecated in favor of the `@rjsf/validator-ajv8\n */\nexport default customizeValidator();\n"],"names":["AJV_CONFIG","errorDataPath","allErrors","multipleOfPrecision","schemaId","unknownFormats","COLOR_FORMAT_REGEX","DATA_URL_FORMAT_REGEX","AJV6Validator","options","this","ajv","additionalMetaSchemas","customFormats","ajvOptionsOverrides","Ajv","addFormat","Array","isArray","addMetaSchema","isObject","Object","keys","forEach","formatName","createAjvInstance","_proto","prototype","toErrorSchema","errors","builder","ErrorSchemaBuilder","length","error","message","path","toPath","property","splice","addErrors","ErrorSchema","toErrorList","errorSchema","fieldPath","_this","errorList","ERRORS_KEY","concat","__errors","map","join","stack","reduce","acc","key","createErrorHandler","formData","_this2","handler","addError","push","formObject","_extends2","_extends","value","_extends3","unwrapErrorHandler","errorHandler","_this3","_extends5","_extends4","transformRJSFValidationErrors","e","schemaPath","dataPath","name","keyword","params","trim","rawValidation","schema","validationError","undefined","validate","err","validateFormData","customValidate","transformErrors","uiSchema","rootSchema","rawErrors","noProperMetaSchema","includes","$schema","newFormData","getDefaultFormState","userErrorSchema","mergeValidationData","withIdRefPrefixObject","node","REF_KEY","startsWith","withIdRefPrefix","withIdRefPrefixArray","i","isValid","addSchema","removeSchema","schemaNode","constructor","customizeValidator","index"],"mappings":"+eAKO,IAAMA,EAAa,CACxBC,cAAe,WACfC,WAAW,EACXC,oBAAqB,EACrBC,SAAU,OACVC,eAAgB,UAELC,EACX,6YACWC,EACX,4DCkBmBC,EAAa,WAgBhC,SAAAA,EAAYC,GAAmCC,KANvCC,SAAG,EASTD,KAAKC,IDxBK,SACZC,EACAC,EACAC,QAAA,IAAAA,IAAAA,EAAyE,CAAA,GAEzE,IAAMH,EAAM,IAAII,eAASf,EAAec,IAkBxC,OAfAH,EAAIK,UAAU,WAAYT,GAC1BI,EAAIK,UAAU,QAASV,GAGnBW,MAAMC,QAAQN,IAChBD,EAAIQ,cAAcP,GAIhBQ,EAAAA,QAASP,IACXQ,OAAOC,KAAKT,GAAeU,SAAQ,SAACC,GAClCb,EAAIK,UAAUQ,EAAYX,EAAcW,GAC1C,IAGKb,CACT,CCAec,CADThB,EADMG,sBACNH,EAD6BI,cAC7BJ,EAD4CK,oBAOhD,CAEA,IAAAY,EAAAlB,EAAAmB,UAqUC,OArUDD,EAmBQE,cAAA,SAAcC,GACpB,IAAMC,EAAU,IAAIC,EAAAA,mBAgBpB,OAfIF,EAAOG,QACTH,EAAON,SAAQ,SAACU,GACd,IAAkBC,EAAYD,EAAZC,QACZC,EAAOC,UADiBH,EAAtBI,UAKJF,EAAKH,OAAS,GAAiB,KAAZG,EAAK,IAC1BA,EAAKG,OAAO,EAAG,GAEbJ,GACFJ,EAAQS,UAAUL,EAASC,EAE/B,IAEKL,EAAQU,WACjB,EAEAd,EAKAe,YAAA,SAAYC,EAA8BC,GAAwB,IAAAC,EAAAlC,KAChE,QADwC,IAAAiC,IAAAA,EAAsB,KACzDD,EACH,MAAO,GAET,IAAIG,EAAmC,GAavC,OAZIC,EAAAA,cAAcJ,IAChBG,EAAYA,EAAUE,OACpBL,EAAYM,SAAUC,KAAI,SAACf,GACzB,IAAMG,EAAeM,IAAAA,EAAUO,KAAK,KACpC,MAAO,CACLb,SAAAA,EACAH,QAAAA,EACAiB,MAAUd,EAAYH,IAAAA,EAEzB,MAGEb,OAAOC,KAAKoB,GAAaU,QAAO,SAACC,EAAKC,GAS3C,OARIA,IAAQR,EAAAA,aACVO,EAAMA,EAAIN,OACRH,EAAKH,YAAaC,EAAkCY,GAAI,GAAAP,OACnDJ,EACHW,CAAAA,OAICD,CACR,GAAER,EACL,EAEAnB,EAKQ6B,mBAAA,SAAmBC,GAAW,IAAAC,EAAA/C,KAC9BgD,EAA2B,CAI/BV,SAAU,GACVW,SAAQ,SAACzB,GACPxB,KAAKsC,SAAUY,KAAK1B,EACtB,GAEF,GAAId,EAAAA,SAASoC,GAAW,CACtB,IAAMK,EAAgCL,EACtC,OAAOnC,OAAOC,KAAKuC,GAAYT,QAAO,SAACC,EAAKC,GAAO,IAAAQ,EACjD,OAAAC,EAAA,CAAA,EAAYV,IAAGS,EAAA,CAAA,GAAGR,GAAMG,EAAKF,mBAAmBM,EAAWP,IAAKQ,GACjE,GAAEJ,EACJ,CACD,OAAIzC,MAAMC,QAAQsC,GACTA,EAASJ,QAAO,SAACC,EAAKW,EAAOV,GAAO,IAAAW,EACzC,OAAYZ,EAAAA,CAAAA,EAAAA,UAAMC,GAAMG,EAAKF,mBAAmBS,GAAMC,GACvD,GAAEP,GAEEA,CACT,EAEAhC,EAKQwC,mBAAA,SAAmBC,GAA+B,IAAAC,EAAA1D,KACxD,OAAOW,OAAOC,KAAK6C,GAAcf,QAAO,SAACC,EAAKC,GAAO,IAAAe,EAGpBC,EAF/B,MAAY,aAARhB,EACKD,EAEPU,EAAA,CAAA,EAAYV,EADHC,IAAQR,eACCQ,EAAAA,CAAAA,GAAAA,GAAOa,EAAmCb,GAAIgB,KAG1DD,EAAA,CAAA,GACLf,GAAMc,EAAKF,mBACTC,EAAmCb,IACrCe,GAEJ,GAAE,CAAoB,EACzB,EAEA3C,EAMQ6C,8BAAA,SACN1C,GAEA,gBAFAA,IAAAA,EAAwB,IAEjBA,EAAOoB,KAAI,SAACuB,GACjB,IAA2BtC,EAAgCsC,EAAhCtC,QAAiBuC,EAAeD,EAAfC,WACtCpC,KADqDmC,EAAnDE,SAIR,MAAO,CACLC,KALyDH,EAAzCI,QAMhBvC,SAAAA,EACAH,QAAAA,EACA2C,OARyDL,EAAvBK,OASlC1B,OAAUd,MAAYH,GAAU4C,OAChCL,WAAAA,EAEJ,GACF,EAEA/C,EAMAqD,cAAA,SACEC,EACAxB,GAEA,IAAIyB,OAAqCC,EACzC,IACExE,KAAKC,IAAIwE,SAASH,EAAQxB,EAG3B,CAFC,MAAO4B,GACPH,EAAkBG,CACnB,CAED,IAAMvD,EAASnB,KAAKC,IAAIkB,aAAUqD,EAKlC,OAFAxE,KAAKC,IAAIkB,OAAS,KAEX,CAAEA,OAAQA,EAA+BoD,gBAAAA,EAClD,EAEAvD,EAWA2D,iBAAA,SACE7B,EACAwB,EACAM,EACAC,EACAC,GAEA,IAAMC,EAAaT,EAEbU,EAAYhF,KAAKqE,cAA2BC,EAAQxB,GAClDyB,EAAoBS,EAApBT,gBACJpD,EAASnB,KAAK6D,8BAA8BmB,EAAU7D,QAEpD8D,EACJV,GACAA,EAAgB/C,SAChB+C,EAAgB/C,QAAQ0D,SAAS,8BAE/BD,IACF9D,EAAM,GAAAkB,OAAOlB,EAAQ,CAAA,CAAEsB,MAAO8B,EAAiB/C,YAElB,mBAApBqD,IACT1D,EAAS0D,EAAgB1D,EAAQ2D,IAGnC,IAAI9C,EAAchC,KAAKkB,cAAcC,GAarC,GAXI8D,IACFjD,EAAWqB,EAAA,CAAA,EACNrB,EACA,CACDmD,QAAS,CACP7C,SAAU,CAACiC,EAAiB/C,aAMN,mBAAnBoD,EACT,MAAO,CAAEzD,OAAAA,EAAQa,YAAAA,GAInB,IAAMoD,EAAcC,EAAAA,oBAClBrF,KACAsE,EACAxB,EACAiC,GACA,GAGItB,EAAemB,EACnBQ,EACApF,KAAK6C,mBAAmBuC,GACxBN,GAEIQ,EAAkBtF,KAAKwD,mBAAmBC,GAChD,OAAO8B,EAAAA,oBACLvF,KACA,CAAEmB,OAAAA,EAAQa,YAAAA,GACVsD,EAEJ,EAEAtE,EAMQwE,sBAAA,SAAsBC,GAC5B,IAAK,IAAM7C,KAAO6C,EAAM,CACtB,IACMnC,EADgCmC,EAChB7C,GADgB6C,EAO5B7C,GAJRA,IAAQ8C,EAAOA,SACE,iBAAVpC,GACPA,EAAMqC,WAAW,KAtSE,oBAwSiBrC,EAErBtD,KAAK4F,gBAAgBtC,EAEvC,CACD,OAAOmC,CACT,EAEAzE,EAMQ6E,qBAAA,SAAqBJ,GAC3B,IAAK,IAAIK,EAAI,EAAGA,EAAIL,EAAKnE,OAAQwE,IAC/BL,EAAKK,GAAK9F,KAAK4F,gBAAgBH,EAAKK,IAEtC,OAAOL,CACT,EAEAzE,EAQA+E,QAAA,SAAQzB,EAAoBxB,EAAyBiC,GACnD,IAQE,OAHe/E,KAAKC,IACjB+F,UAAUjB,EA5UQ,qBA6UlBN,SAASzE,KAAK4F,gBAAgBtB,GAASxB,EAO3C,CALC,MAAOgB,GACP,OAAO,CACR,CAAS,QAER9D,KAAKC,IAAIgG,aAnVY,oBAoVtB,CACH,EAEAjF,EAMU4E,gBAAA,SAAgBM,GACxB,OAAIA,EAAWC,cAAgBxF,OACtBX,KAAKwF,sBAAqBnC,EAAA,CAAA,EAAM6C,IAErC3F,MAAMC,QAAQ0F,GACTlG,KAAK6F,qBAAoB,GAAAxD,OAAK6D,IAEhCA,GACRpG,CAAA,CA/V+B,GCjBpB,SAAUsG,EAItBrG,GACA,gBADAA,IAAAA,EAAsC,CAAA,GAC/B,IAAID,EAAuBC,EACpC,CCfA,IAAAsG,EAAeD"}